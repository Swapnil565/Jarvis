"""
=============================================================================
JARVIS 3.0 - EVENT TRACKING DATABASE (SQLite Event/Pattern/Intervention Storage)
=============================================================================

PURPOSE:
--------
This is the MAIN DATABASE MODULE for JARVIS event tracking system. Manages
three core tables: events (user activities), patterns (detected correlations),
and interventions (recommendations). This is separate from simple_db.py which
handles user authentication.

RESPONSIBILITY:
---------------
- Initialize and manage jarvis_events.db SQLite database
- Store events across 3 dimensions: physical, mental, spiritual
- Track patterns detected by PatternDetectorAgent (Day 3)
- Store interventions generated by InterventionistAgent (Day 4)
- Provide CRUD operations (Create, Read, Update, Delete) for all tables
- Calculate statistics (event counts, streaks, dimension breakdowns)

DATA FLOW (Event Lifecycle):
-----------------------------
EVENT CREATION FLOW:
1. User sends request to simple_main.py endpoint (POST /api/events)
2. DataCollectorAgent parses natural language → structured JSON
3. simple_main.py calls jarvis_db.create_event(user_id, category, event_type, feeling, data)
4. This module connects to jarvis_events.db
5. Execute INSERT INTO events with validated data
6. Return event_id for the new record
7. simple_main.py returns EventResponse to client

EVENT RETRIEVAL FLOW:
1. Client requests GET /api/events?category=physical&date_from=2024-01-01
2. simple_main.py calls jarvis_db.get_events(user_id, filters)
3. This module builds dynamic SQL query with WHERE clauses
4. Execute SELECT with user-specific filtering
5. Convert SQLite Row objects to Python dicts
6. Return list of events with metadata
7. simple_main.py formats as EventListResponse

PATTERN DETECTION FLOW (Day 3):
1. PatternDetectorAgent analyzes events for correlations
2. Finds: "Workout → Increased task completion" correlation
3. Calls jarvis_db.create_pattern(user_id, pattern_type, description, confidence, data)
4. INSERT INTO patterns table
5. Return pattern_id

INTERVENTION FLOW (Day 4):
1. InterventionistAgent generates recommendation
2. Calls jarvis_db.create_intervention(user_id, intervention_type, title, message, urgency)
3. INSERT INTO interventions table
4. Return intervention_id for tracking

DATABASE SCHEMA:
----------------
Table: events
- id (INTEGER PRIMARY KEY)
- user_id (INTEGER) - Foreign key to users table
- category (TEXT) - physical/mental/spiritual
- event_type (TEXT) - workout/task/meditation/etc
- feeling (TEXT) - User's mood/feeling (optional)
- data (TEXT) - JSON blob with event-specific data
- timestamp (TEXT) - ISO format creation time

Table: patterns (Day 3)
- id, user_id, pattern_type, description, confidence, data, detected_at

Table: interventions (Day 4)
- id, user_id, intervention_type, title, message, urgency, status, created_at

DEPENDENCIES:
-------------
- sqlite3: Database operations
- json: Serialize/deserialize data column (Python dict ↔ JSON string)
- datetime: Timestamp generation
- contextlib: Context manager for connection cleanup

USED BY:
--------
- simple_main.py: All event CRUD operations
- agents/pattern_detector.py: (Day 3) Pattern storage
- agents/interventionist.py: (Day 4) Intervention storage
"""

import sqlite3
import json
from datetime import datetime
from typing import Optional, List, Dict, Any
from contextlib import contextmanager


class SimpleJarvisDB:
    """Simple SQLite database for JARVIS event tracking"""
    
    def __init__(self, db_path: str = "jarvis_events.db"):
        self.db_path = db_path
        self.init_database()
    
    @contextmanager
    def get_connection(self):
        """Context manager for database connections"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row  # Return rows as dictionaries
        try:
            yield conn
            conn.commit()
        except Exception as e:
            conn.rollback()
            raise e
        finally:
            conn.close()
    
    def init_database(self):
        """Initialize database with required tables"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            
            # Events table - tracks physical/mental/spiritual activities
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS events (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    category TEXT NOT NULL,  -- physical, mental, spiritual
                    event_type TEXT NOT NULL,  -- workout, task, meditation, etc.
                    timestamp TEXT NOT NULL,
                    feeling TEXT,  -- energized, tired, calm, stressed
                    data TEXT NOT NULL,  -- JSON data for event-specific info
                    FOREIGN KEY (user_id) REFERENCES users (id)
                )
            """)
            
            # Patterns table - stores detected correlations
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS patterns (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    pattern_type TEXT NOT NULL,  -- correlation, trend, anomaly
                    description TEXT NOT NULL,
                    confidence REAL NOT NULL,  -- 0-1 confidence score
                    frequency INTEGER DEFAULT 1,
                    first_detected TEXT NOT NULL,
                    last_seen TEXT NOT NULL,
                    data TEXT NOT NULL,  -- JSON pattern metadata
                    is_active INTEGER DEFAULT 1,  -- Boolean: 1=active, 0=inactive
                    FOREIGN KEY (user_id) REFERENCES users (id)
                )
            """)
            
            # Interventions table - proactive suggestions
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS interventions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    intervention_type TEXT NOT NULL,  -- warning, suggestion, insight, forecast
                    urgency TEXT NOT NULL,  -- low, medium, high, critical
                    title TEXT NOT NULL,
                    message TEXT NOT NULL,
                    created_at TEXT NOT NULL,
                    delivered_at TEXT,
                    acknowledged_at TEXT,
                    user_rating INTEGER,  -- 1-5 stars
                    was_helpful INTEGER,  -- Boolean: 1=yes, 0=no
                    data TEXT NOT NULL,  -- JSON supporting data
                    FOREIGN KEY (user_id) REFERENCES users (id)
                )
            """)
            
            # Indexes for performance
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_events_user_timestamp ON events(user_id, timestamp)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_events_category ON events(category)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_patterns_user_active ON patterns(user_id, is_active)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_interventions_user_created ON interventions(user_id, created_at)")
    
    # ==================== EVENT OPERATIONS ====================
    
    def create_event(self, user_id: int, category: str, event_type: str, 
                    feeling: Optional[str] = None, data: Dict[str, Any] = None) -> int:
        """Create a new event and return its ID"""
        timestamp = datetime.utcnow().isoformat()
        data_json = json.dumps(data or {})
        
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO events (user_id, category, event_type, timestamp, feeling, data)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (user_id, category, event_type, timestamp, feeling, data_json))
            return cursor.lastrowid
    
    def get_event_by_id(self, event_id: int) -> Optional[Dict[str, Any]]:
        """Get event by ID"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM events WHERE id = ?", (event_id,))
            row = cursor.fetchone()
            if row:
                return self._row_to_dict(row, parse_data=True)
            return None
    
    def get_events(self, user_id: int, category: Optional[str] = None, 
                   date_from: Optional[str] = None, date_to: Optional[str] = None,
                   event_type: Optional[str] = None, limit: int = 100) -> List[Dict[str, Any]]:
        """Get events with optional filters"""
        query = "SELECT * FROM events WHERE user_id = ?"
        params = [user_id]
        
        if category:
            query += " AND category = ?"
            params.append(category)
        
        if event_type:
            query += " AND event_type = ?"
            params.append(event_type)
        
        if date_from:
            query += " AND timestamp >= ?"
            params.append(date_from)
        
        if date_to:
            query += " AND timestamp <= ?"
            params.append(date_to)
        
        query += " ORDER BY timestamp DESC LIMIT ?"
        params.append(limit)
        
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(query, params)
            rows = cursor.fetchall()
            return [self._row_to_dict(row, parse_data=True) for row in rows]
    
    def get_events_today(self, user_id: int) -> List[Dict[str, Any]]:
        """Get all events logged today"""
        today = datetime.utcnow().date().isoformat()
        return self.get_events(user_id, date_from=today, limit=1000)
    
    def delete_event(self, event_id: int, user_id: int) -> bool:
        """Delete an event (only if owned by user)"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM events WHERE id = ? AND user_id = ?", (event_id, user_id))
            return cursor.rowcount > 0
    
    # ==================== PATTERN OPERATIONS ====================
    
    def create_pattern(self, user_id: int, pattern_type: str, description: str,
                      confidence: float, data: Dict[str, Any] = None) -> int:
        """Create a new pattern"""
        timestamp = datetime.utcnow().isoformat()
        data_json = json.dumps(data or {})
        
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO patterns (user_id, pattern_type, description, confidence, 
                                    frequency, first_detected, last_seen, data, is_active)
                VALUES (?, ?, ?, ?, 1, ?, ?, ?, 1)
            """, (user_id, pattern_type, description, confidence, timestamp, timestamp, data_json))
            return cursor.lastrowid
    
    def get_patterns(self, user_id: int, active_only: bool = True) -> List[Dict[str, Any]]:
        """Get user's patterns"""
        query = "SELECT * FROM patterns WHERE user_id = ?"
        params = [user_id]
        
        if active_only:
            query += " AND is_active = 1"
        
        query += " ORDER BY confidence DESC, last_seen DESC"
        
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(query, params)
            rows = cursor.fetchall()
            return [self._row_to_dict(row, parse_data=True) for row in rows]
    
    def update_pattern_frequency(self, pattern_id: int, user_id: int) -> bool:
        """Increment pattern frequency and update last_seen"""
        timestamp = datetime.utcnow().isoformat()
        
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                UPDATE patterns 
                SET frequency = frequency + 1, last_seen = ?
                WHERE id = ? AND user_id = ?
            """, (timestamp, pattern_id, user_id))
            return cursor.rowcount > 0
    
    def deactivate_pattern(self, pattern_id: int, user_id: int) -> bool:
        """Mark pattern as inactive"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                UPDATE patterns SET is_active = 0 
                WHERE id = ? AND user_id = ?
            """, (pattern_id, user_id))
            return cursor.rowcount > 0
    
    # ==================== INTERVENTION OPERATIONS ====================
    
    def create_intervention(self, user_id: int, intervention_type: str, urgency: str,
                           title: str, message: str, data: Dict[str, Any] = None) -> int:
        """Create a new intervention"""
        timestamp = datetime.utcnow().isoformat()
        data_json = json.dumps(data or {})
        
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO interventions (user_id, intervention_type, urgency, title, 
                                         message, created_at, data)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            """, (user_id, intervention_type, urgency, title, message, timestamp, data_json))
            return cursor.lastrowid
    
    def get_interventions(self, user_id: int, unread_only: bool = False, 
                         limit: int = 50) -> List[Dict[str, Any]]:
        """Get user's interventions"""
        query = "SELECT * FROM interventions WHERE user_id = ?"
        params = [user_id]
        
        if unread_only:
            query += " AND acknowledged_at IS NULL"
        
        query += " ORDER BY created_at DESC LIMIT ?"
        params.append(limit)
        
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(query, params)
            rows = cursor.fetchall()
            return [self._row_to_dict(row, parse_data=True) for row in rows]
    
    def mark_intervention_delivered(self, intervention_id: int, user_id: int) -> bool:
        """Mark intervention as delivered"""
        timestamp = datetime.utcnow().isoformat()
        
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                UPDATE interventions SET delivered_at = ?
                WHERE id = ? AND user_id = ?
            """, (timestamp, intervention_id, user_id))
            return cursor.rowcount > 0
    
    def acknowledge_intervention(self, intervention_id: int, user_id: int) -> bool:
        """Mark intervention as acknowledged/read"""
        timestamp = datetime.utcnow().isoformat()
        
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                UPDATE interventions SET acknowledged_at = ?
                WHERE id = ? AND user_id = ?
            """, (timestamp, intervention_id, user_id))
            return cursor.rowcount > 0
    
    def rate_intervention(self, intervention_id: int, user_id: int, 
                         rating: int, was_helpful: bool) -> bool:
        """Add user feedback to intervention"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                UPDATE interventions 
                SET user_rating = ?, was_helpful = ?
                WHERE id = ? AND user_id = ?
            """, (rating, 1 if was_helpful else 0, intervention_id, user_id))
            return cursor.rowcount > 0
    
    # ==================== UTILITY METHODS ====================
    
    def _row_to_dict(self, row: sqlite3.Row, parse_data: bool = False) -> Dict[str, Any]:
        """Convert SQLite row to dictionary"""
        result = dict(row)
        
        # Parse JSON data field if requested
        if parse_data and 'data' in result and result['data']:
            try:
                result['data'] = json.loads(result['data'])
            except json.JSONDecodeError:
                result['data'] = {}
        
        # Convert boolean fields (SQLite stores as integers)
        if 'is_active' in result:
            result['is_active'] = bool(result['is_active'])
        if 'was_helpful' in result and result['was_helpful'] is not None:
            result['was_helpful'] = bool(result['was_helpful'])
        
        return result
    
    def get_stats(self, user_id: int) -> Dict[str, Any]:
        """Get user statistics"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            
            # Count events by category
            cursor.execute("""
                SELECT category, COUNT(*) as count 
                FROM events 
                WHERE user_id = ? 
                GROUP BY category
            """, (user_id,))
            events_by_category = dict(cursor.fetchall())
            
            # Count active patterns
            cursor.execute("""
                SELECT COUNT(*) FROM patterns 
                WHERE user_id = ? AND is_active = 1
            """, (user_id,))
            active_patterns = cursor.fetchone()[0]
            
            # Count unread interventions
            cursor.execute("""
                SELECT COUNT(*) FROM interventions 
                WHERE user_id = ? AND acknowledged_at IS NULL
            """, (user_id,))
            unread_interventions = cursor.fetchone()[0]
            
            return {
                "total_events": sum(events_by_category.values()),
                "events_by_category": events_by_category,
                "active_patterns": active_patterns,
                "unread_interventions": unread_interventions
            }


# Global instance
jarvis_db = SimpleJarvisDB()
